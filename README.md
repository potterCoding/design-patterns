# design-patterns
## 阅读《Head First设计模式》一书的笔记
### 第一章要点
- 知道面向对象（OO）基础，并不足以让你设计出良好的面向对象（OO）系统
- 良好的OO设计必须具备可用复用、可扩充、可维护三个热性
- 模式可以让我们建造出具有良好的OO设计质量的系统
- 模式被认为是历经验证的OO设计经验
- 模式不是代码，而是针对设计问题的通用解决方案，你把它们应用到特定的应用中
- 模式不是被发明，而是被实现
- 大多数的模式和原则，都着眼于软件变化的主题
- 大多数的模式都允许系统局部改变独立于其他部分
- 我们通常把系统中，会变化的部分抽出来封装
- 模式让开发人员之间有共享的语言，最大化沟通的价值

#### 第二章要点
- 观察者模式定义了对象之间一对多的关系
- 主题（也就是可观察者）用一个共同的接口来更新观察者
- 观察者和可观察者之间用松耦合方式结合（loosecoupling），可观察者不知道观察者的细节，只知道观察者实现了观察者接口
- 使用此模式时，你可从被观察者处推（push）或拉（pull）数据（然而，推的方式被认为更“正确”）
- 有多个观察者时，不可以依赖特定的通知顺序
- Java有多种观察者模式的实现，包括了通用的java.util.Observable
- 要注意java.util.Observable实现上所带来的一些问题。
- 如果有必要的话，可以实现自己的Observable，这并不难，不要害怕
- Swing大量使用观察者模式，许多GUI框架也是如此

#### 第三章知识要点
- 继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式。
- 在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码。
- 组合和委托可用于在运行时动态地加上新的行为。
- 除了继承，装饰者模式也可以让我们扩展行为。
- 装饰者模式意味着一群装饰者类，这些类用来包装具体组件
- 装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）
- 装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。
- 你可以用无数个装饰者包装一个组件。
- 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。
- 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。

#### 第四章知识要点
- 所有的工厂都是用来封装对象的创建
- 简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类中解耦
- 工厂方法使用继承：把对象的创建委托给了子类，子类实现工厂方法来创建对象
- 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中
- 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合
- 工厂方法允许类将实例化延迟到子类进行
- 抽象工厂创建相关的对象家族，而不需要依赖他们的具体类
- 依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象
- 工厂是很有威力的技巧，帮助我们针对抽象编程，而不要针对具体类编程

#### 第五章知识要点
- 单例模式确保程序中一个类最多只有一个实例
- 单例模式也提供访问这个实例的全局点
- 在Java中 实现单例模式需要私有的构造器、一个静态变量和一个静态方法
- 确定在性能和资源上的限制，然后小心地选择合适的方案来实现单例，以解决多线程问题（我们必须认定所有的程序都是多线程的）
- 小心，你如果使用多个类加载器，可能会导致单例失效而产生多个实例
- 如果不是采用的jdk1.5或以上版本，双重检查加锁实现会失效
- 如果是使用的jdk1.2或之前的版本，你必须建立单例注册表，以免垃圾收集器将单例回收

#### 第六章知识要点
- 命令模式将发出请求的对象和执行请求的对象解耦
- 在被解耦的两者之间是通过命令对象进行沟通的。命令对象封装了接收者和一个或一组动作
- 调用者通过调用命令对象的execute()发出请求，这会使得接收者的动作被调用
- 调用者可以接受命令当作参数，甚至在运行时动态地进行
- 命令可以支持撤销，做法是实现一个undo()方法来回到execute()方法执行之前的状态
- 宏命令是命令的一种简单的延申，允许调用多个命令。宏方法也支持撤销
- 实际操作时，很常见使用“聪明”的命令对象，也就是直接实现了请求，而不是将工作委托给接收者
- 命令也可以用来实现日志和事务系统

#### 第七章知识要点
- 当需要使用一个现有的类而其并不符合你的需要时，就使用适配器
- 当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观
- 适配器改变接口以符合客户的期望
- 外观将客户从一个复杂的子系统中解耦
- 实现一个适配器可能需要一番功夫，也可能不费功夫，视目标接口的大小与复杂度而定
- 实现一个外观，需要将子系统组合到外观中，然后将工作委托给子系统执行
- 适配器模式有两种形式：对象适配器和类适配器。类适配器需要用到多继承
- 你可以为一个子系统实现一个以上的外观
- 适配器将一个对象包装起来以改变其接口；装饰者将一个对象包装以增加新的行为和责任；而外观将一群对象”包装“起来以简化其接口

#### 第八章知识要点
- “模板方法”定义了算法的步骤，把这些步骤的实现延迟到子类
- 模板方法模式为我们提供了一种代码复用的重要技巧
- 模板方法的抽象类可以定义具体方法，抽象方法和钩子
- 抽象方法由子类实现
- 钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以去选择要不要覆盖它
- 为了防止子类改变模板方法中的算法，可以将模板方法声明为final
- 好莱坞原则告诉我们，将决策权放在高层模块中，以便决定如何以及何时调用底层模块
- 你将在真实世界代码中看到模板方法的许多变体，不要期望他们全都是一眼就可以被你认出的
- 策略模式和模板方法模式都封装算法，一个用组合，一个用继承
- 工厂方法是模板方法的一个特殊版本

### 设计原则
1. 把会变化的部分取出并封装起来，以便以后可以轻易地扩充此部分，而不影响不需要变化的其他部分
2. 针对接口编程，而不是针对实现编程
3. 多用组合，少用继承
4. 为了交互对象之间的松耦合设计而努力
5. 开放-关闭原则：类应该对扩展开放，对修改关闭
6. 依赖倒置原则：要依赖抽象，不要依赖具体类。不能让高层组件依赖底层组件。
   + 几个指导方针帮助实现该原则：
      - 变量不可以持有具体类的引用。如果使用new,就会持有具体类的引用，你可以改用工厂来避开这样的做法
      - 不要让类派生自具体类。如果派生自具体类，你就会依赖具体类，请派生自一个抽象（接口或抽象类）。
      - 不要覆盖基类中已实现的方法。如果覆盖基类已实现的方法，那么你得基类就不是一个真正适合被继承的抽象，基类中已实现的方法，应该由所有的子类共享。
7. 最少知道原则：只和你的密友谈话
   + 几个指导方针帮助实现该原则：在该对象的方法内，我们只应该调用属于以下范围的方法：
      - 该对象本身
      - 被当作方法的参数而传递进来的对象
      - 此方法所创建或实例化的任何对象
      - 对象的任何组件：把”组件“想象成被任何实例变量所引用的任何对象，换句话说，把这想象成”有一个(HAS-A)“关系
8. 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你
    - 换句话说就是：高层组件对待底层组件的方式就是“别调用我们，我们会调用你”
    - 底层组件绝对不可以直接调用高层组件


### 设计模式
1. 策略模式：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户
2. 观察者模式： 定义了对象之间一对多的依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新
3. 装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案
4. 工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类
5. 抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
6. 单例模式：确保一个类只有一个实例，并提供一个全局访问点
7. 命令模式：将“请求”封装成对象，以便使用不同的请求、队列或者日志参数化其他对象。命令模式也可以支持撤销的操作
8. 适配器模式：将一个类得接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间
9. 外观模式：提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用
10. 模板方法：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。
